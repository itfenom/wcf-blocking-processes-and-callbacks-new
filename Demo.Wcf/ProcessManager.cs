using Demo.Contracts;
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.Threading;
using System.Threading.Tasks;

namespace Demo.Wcf
{
    [ServiceBehavior(ConcurrencyMode = ConcurrencyMode.Reentrant)]
    public class ProcessManager : IProcess
    {
        public static List<IProcessCallback> Clients { get; }

        static ProcessManager()
        {
            Clients = new List<IProcessCallback>();
        }

        public bool Connect()
        {
            var callbackClient = OperationContext.Current.GetCallbackChannel<IProcessCallback>();
            if (callbackClient == null) return ProcessHelper.IsInProcess;

            if (Clients.Contains(callbackClient)) return ProcessHelper.IsInProcess;
            Clients.Add(callbackClient);

            return ProcessHelper.IsInProcess;
        }

        public void Disconnect()
        {
            var callbackClient = OperationContext.Current.GetCallbackChannel<IProcessCallback>();
            if (callbackClient == null) return;

            if (!Clients.Contains(callbackClient)) return;
            Clients.Remove(callbackClient);
        }

        public void StartProcess()
        {
            Task.Run(() =>
            {
                ProcessHelper.StartProcess();
            });
        }
    }

    public static class ProcessHelper
    {
        public static bool IsInProcess { get; set; }

        private static List<int> list = new List<int>();

        public static void StartProcess()
        {
            if (IsInProcess) return;

            IsInProcess = true;
            var rnd = new Random(100000);

            for (var i = 0; i < 5; i++)
            {
                var nr = rnd.Next();
                list.Add(nr);
                Console.WriteLine("Generated by the service: {0}", nr);

                var canceled = NotifyClients(nr);

                if (canceled)
                {
                    break;
                }
                else
                {
                    Thread.Sleep(1500);
                }                
            }

            NotifyClients(0);

            IsInProcess = false;
        }

        private static bool NotifyClients(int nr)
        {
            lock (ProcessManager.Clients)
            {
                var isCanceled = false;

                foreach (var client in ProcessManager.Clients)
                {
                    try
                    {
                        var canceled = client.ReportBack(nr);
                        if (canceled)
                        {
                            isCanceled = true;
                        }
                    }
                    catch (CommunicationException ex)
                    {

                    }
                }

                return isCanceled;
            }
        }
    }
}
